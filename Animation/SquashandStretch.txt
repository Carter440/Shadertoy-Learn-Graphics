//Carter S. Feb 2020
//Simple demonstration of the Principle of Squash and Stretch in 3D.
//Bounces are not simulated and better results can be achieved by maintaining constant volume
//


#define PI 3.14159265359
#define AA 1
#define LOOP_TIME 10.0
#define GRAV -9.8
//should probs calc this on the fly
#define BTIME 0.5102 
#define BALLSIZE 0.4

//Ray hit struct
struct Hit {
	vec3 pos;
    vec3 normal;
    float mat;
};
   
//ray struct
struct Ray {
	vec3 origin;
    vec3 direction;
};


//geometric attenuation (or shadow factor)
float geometric_attenuation(float roughness, float normal_look_angle, float normal_light_angle)
{
	float r2 = roughness * roughness;
	float gv = normal_light_angle * sqrt(normal_look_angle * (normal_look_angle - normal_look_angle * r2) + r2);
	float gl = normal_look_angle * sqrt(normal_light_angle* (normal_light_angle - normal_light_angle * r2) + r2);
	return 0.5 / max(gv + gl, 0.00001);
}

//microfacets (minute roghness in the surface)
float microfacet_distribution(float roughness, float normal_half_angle){
	float r2 = roughness * roughness;
	float d = (normal_half_angle * r2 - normal_half_angle) * normal_half_angle + 1.0;
	return r2 / (d * d * PI);
}

//Fresnel Reflection coefficient (vector)
vec3 fresnel_vec(vec3 specular_color,float look_light_angle) {
	return specular_color + (1.0 - specular_color) * pow((1.0 - look_light_angle),5.0);
}

//Fresnel Reflection coefficient (scalar)
float fresnel_scalar(float f0, float f90, float look_half_angle) {
    return f0 + (f90 - f0) * pow(1.0 - look_half_angle, 5.0);
}

float Burley(float linearRoughness, float normal_look_vector, float normal_light_angle, float light_half_angle) {
    // Burley 2012, "Physically-Based Shading at Disney"
    float f90 = 0.5 + 2.0 * linearRoughness * light_half_angle * light_half_angle;
    float lightScatter = fresnel_scalar(1.0, f90, normal_light_angle);
    float viewScatter  = fresnel_scalar(1.0, f90, normal_look_vector);
    return lightScatter * viewScatter * (1.0 / PI);
}

vec3 spherical_harmonics(const vec3 n) {
    // Irradiance from "Ditch River" IBL (http://www.hdrlabs.com/sibl/archive.html)
    return max(
          vec3( 0.754554516862612,  0.748542953903366,  0.790921515418539)
        + vec3(-0.083856548007422,  0.092533500963210,  0.322764661032516) * (n.y)
        + vec3( 0.308152705331738,  0.366796330467391,  0.466698181299906) * (n.z)
        + vec3(-0.188884931542396, -0.277402551592231, -0.377844212327557) * (n.x)
        , 0.0);
}

vec2 dfg_karis(float roughness, float normal_look_angle) {
    // Karis 2014, "Physically Based Material on Mobile"
    const vec4 c0 = vec4(-1.0, -0.0275, -0.572,  0.022);
    const vec4 c1 = vec4( 1.0,  0.0425,  1.040, -0.040);

    vec4 r = roughness * c0 + c1;
    float a004 = min(r.x * r.x, exp2(-9.28 * normal_look_angle)) * r.x + r.y;

    return vec2(-1.04, 1.04) * a004 + r.zw;
}

//From IQ ellipsoid approximation
float sdEllipsoid( vec3 p, vec3 r )
{
  float k0 = length(p/r);
  float k1 = length(p/(r*r));
  return k0*(k0-1.0)/k1;
}

float sdSphere(vec3 pos, vec3 c, float r) {
	return length(pos - c) - r;
}

//distance to plane
float sdPlane( vec3 p, vec4 n )
{
  return dot(p,n.xyz) + n.w;
}


//Animation code
//-------------------------------------------------------------------------------------
vec3 Animate_Sphere(){//stateless animation (perfectly elastic)
    vec3 pos = vec3(0.0,0.0,0.0);//start
	float time = mod(iTime+8.0*BTIME,LOOP_TIME);//Ten second loop (I've added an offset to this example)
    pos.x = mix(-2.0,2.0,time/LOOP_TIME);//x velocity is constant so x postion is linear
    float ytime = mod(time,2.0*BTIME);//each bounce takes 1.0204 seconds
    pos.y = 5.0*ytime + 0.5*GRAV*ytime*ytime;//analytic bounce (no energy loss)
    
    
    //as a side not you can get the ball to bounce in any direction by adding a rotation here
    return pos;
}

void Animate_Ball(out vec3 pos, out vec3 sqst, out mat2 rotate){//stateless animation
    float time = mod(iTime,LOOP_TIME);//Ten second loop
    pos.x = mix(-2.0,2.0,time/LOOP_TIME);//x velocity is constant so x postion is linear
    float ytime = mod(time,2.0*BTIME);//each bounce takes 1.0204 seconds by default
    pos.y = 5.0*ytime + 0.5*GRAV*ytime*ytime;//analytic bounce (no energy loss)
    float vel = 5.0 + GRAV*ytime; //derivative of position with respect to time is velocity
    
    //The following lines set up the interpolation between the squash and stretch based on where we are in the bounce arc
	float stime = BTIME/3.0;
    float sint = 1.0;
    if (ytime < stime) {
    	sint = ytime/stime;
    }
    if (ytime > (2.0*BTIME - stime)) {
    	sint = (2.0*BTIME - ytime)/stime;
    }
    //init squash and stretch values
    float stretch = 1.0 + pow(vel,2.0)*0.05; //squash and stretch need not be linearly proportional to velocity (sometimes exponential is better looking)
    float squash = 1.0 + pow(vel,2.0)*0.025; //play with these values for more/less cartoonish effect
    //mix the two vectors to get bouncy effect
    //the squash should be applied negatively to the x component here but it makes it difficult to contact the ground
    sqst = mix(vec3(1.0,squash,squash),vec3(stretch,1.0 - stretch*0.12,1.0 - stretch*0.12), sint);
    
    float theta = atan(vel,0.8);//angle of the 2d velocity vector
    rotate = mat2(vec2(cos(theta),-sin(theta)),vec2(sin(theta),cos(theta)));//2D rotation matrix
}
//-------------------------------------------------------------------------------------


//PB Rendering Code
//-------------------------------------------------------------------------------------
//This function grows with more objects and operations (unions, distortions, perturbations, ect)
//This is usually where acceleration structures and ad hoc hackery goes down
//x  index is distance, y index is material type (sometimes other meta info)
vec2 map_the_world(in vec3 p)
{
    vec3 b_center = vec3(0.0);
    vec3 b_squash = vec3(1.0);
    mat2 b_rotate = mat2(vec2(1.0,0.0),vec2(0.0,1.0));
    Animate_Ball(b_center,b_squash, b_rotate);
    
    vec3 sp_center = Animate_Sphere();
    //perform inverse transformation to point before applying to sdf
    vec3 ball_point = p - b_center;
    ball_point.xy = b_rotate*ball_point.xy;
    
    
    float to_sphere = sdSphere(p, sp_center ,BALLSIZE);
	float to_ball = sdEllipsoid( ball_point, b_squash*BALLSIZE );
    float to_plane = sdPlane (p, vec4(0.0,1.0,0.0,0.4));
    if (to_ball < to_plane && to_ball < to_sphere) {
    	return vec2(to_ball, 1.0);
    }else if (to_sphere < to_plane){
    	return vec2(to_sphere, 1.0);
    }else{
    	return vec2(to_plane, 2.0);
    }

}


//Find the normal of the surface at this point P
vec3 calculate_normal( in vec3 pos)
{
    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;
    const float eps = 0.0005;
    return normalize( e.xyy*map_the_world( pos + e.xyy ).x + 
					  e.yyx*map_the_world( pos + e.yyx ).x + 
					  e.yxy*map_the_world( pos + e.yxy ).x + 
					  e.xxx*map_the_world( pos + e.xxx ).x );  
}

//Basic RayMarch
Hit march_ray(Ray ray, float tmax) {
	float t = 0.0;//current depth
    float m = 0.0;
    vec3 pos = vec3(0.0);
    for( int i=0; i<256; i++ )
    {
        pos = ray.origin + t*ray.direction;
        //get dist to nearest surface
        vec2 h = map_the_world(pos);
        m = h.y;
        //if we hit something break
        if( h.x<0.0001) break;
        if( t > tmax){m = 0.0; break;}
        //step forward
        t += h.x*0.9;
    }
    return Hit(pos, calculate_normal(pos), m);
}

vec3 render_ray(Ray ray) {
	// init "sky" color
    vec3 color = vec3(0.5, 0.8, 1.0) * (1.0 + ray.direction.y) * 0.8;

    // raytrace
    Hit result = march_ray(ray,8.0);

    vec3 light_pos = vec3(10.0);
    vec3 light_dir = normalize(result.pos - light_pos);
    vec3 look = -ray.direction;//vector to camera
    
    if (result.mat > 0.999){//hit someting
       
        vec3 half_vec = normalize(look - light_dir);
        
        //important angles
        float normal_look_angle = clamp(dot(result.normal, look),0.0,1.0);
        float normal_light_angle = clamp(dot(result.normal, normalize(light_pos)), 0.0,1.0);
        float look_light_angle = clamp(dot(look, normalize(light_pos)), 0.0,1.0);
        float normal_half_angle = clamp(dot(result.normal, half_vec), 0.0,1.0);
        float look_half_angle = clamp(dot(look,half_vec), 0.0,1.0);
        float light_half_angle = clamp(dot(normalize(light_pos),half_vec), 0.0,1.0);
        
        //material constants (play with these)
        float metallic = 0.0; 
        float reflect_intensity = 1.0;
        float specular_intensity = 2.5;
        float roughness = 0.0;
   		
        vec3 base_color = vec3(0.0);
        //shadow check ray
        Ray shadow_ray = Ray(result.pos+0.01*light_pos, normalize(light_pos));
       	//Ray Trace shadow
        Hit shadow = march_ray(shadow_ray, 8.0);
            
        if (result.mat > 1.999) {//plane (play with theses values)
            //checkerboard
            base_color = 0.4 + mod(floor(6.0 * result.pos.z) + floor(6.0 * result.pos.x), 2.0)*vec3(0.5);
            roughness = 0.1;//play with this
        }else{//sphere (play with these values)
        	base_color = vec3(0.2,0.2,0.2);//sphere color
            roughness = 0.3;//play with this
        }
        
        
        
        float linear_roughness = roughness*roughness;
        //init specular color
        vec3 specular_initial = 0.04 * (1.0 - metallic) + base_color*metallic;
        //init diffuse color
        vec3 diffuse_initial = (1.0 - metallic) * base_color;
        // Cook-Torrance
        vec3 specular = (microfacet_distribution(linear_roughness,normal_half_angle) 
            		* geometric_attenuation(linear_roughness, normal_look_angle, normal_light_angle))
            		* fresnel_vec(specular_initial,light_half_angle); 
       	//This is the wierd one (lots of different solutions dpending on what you read)
        vec3 diffuse = diffuse_initial * Burley(linear_roughness, normal_look_angle, normal_light_angle, light_half_angle);
        
        //combine
        color = diffuse + specular;

        //alter combo by shadows and light angle
        color *= (specular_intensity * clamp( 1.0 - shadow.mat, 0.0, 1.0) * normal_light_angle);
        //Reflection Check
        vec3 ref_dir = reflect(ray.direction, result.normal);
       	Ray reflected_ray = Ray(result.pos + 0.03*ref_dir,ref_dir);
        Hit reflected = march_ray(reflected_ray,8.0);
        
        
        //reflected Diffuse calculation
        vec3 reflected_diffuse = spherical_harmonics(result.normal) * (1.0/PI);
        //reflected Specular initial
        vec3 reflected_specular = vec3(0.65, 0.85, 1.0) + reflected_ray.direction.y * 0.8;
        //what did the reflect hit?
        if (reflected.mat > 0.999) {
            if (reflected.mat > 1.999) {
                //reflected onto the gorund
            	reflected_specular = 0.4 + mod(floor(6.0 * reflected.pos.z) + floor(6.0 * reflected.pos.x), 2.0)*vec3(0.5);
            }else{
                //reflected onto the sphere
            	reflected_specular = vec3(0.2,0.2,0.2);
            }
        }
        
        //how to combine the diffuse and specular reflections
        vec2 dfg = dfg_karis(roughness, normal_look_angle);
        vec3 spec_color = specular_initial * dfg.x + dfg.y;
        vec3 reflected_combo = diffuse_initial * reflected_diffuse + reflected_specular * spec_color; 
        //combine 1st and second bounces
        color += reflected_combo*reflect_intensity;
        
    }

    // gamma color calculation    
    return color;
}

//-------------------------------------------------------------------------------------
void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    
//Camera + Ray Setup
//----------------------------------------------------------------------
    // camera movement	
	float an = 0.5*(PI);
	vec3 ray_origin = vec3( 2.5*cos(an), 0.4, 2.5*sin(an) );
    vec3 origin = vec3( 0.0, 0.0, 0.0 );
    // camera matrix (for ease of animation)
    vec3 ww = normalize( origin - ray_origin );
    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );
    vec3 vv = normalize( cross(uu,ww));

    
    //initialize total color
    vec3 total = vec3(0.0);
    
    #if AA>1
    for( int m=0; m<AA; m++ )
    for( int n=0; n<AA; n++ )
    {
    vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;
    vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;
    #else  
 	//what pixel are we marching through
    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;
    #endif
	// create view ray
    vec3 ray_direction = normalize( p.x*uu + p.y*vv + 1.0*ww );
    
    Ray ray = Ray(ray_origin, ray_direction);
    
//Render Fragment
//----------------------------------------------------------------------
    
	total += render_ray(ray);
        
    #if AA>1
    }
    total /= float(AA*AA);
    #endif

    total = pow(total, vec3(1.0/2.2));
    
	fragColor = vec4( total, 1.0 );
}